# redstr - Cursor Rules

## ⚠️ CRITICAL FOR AI AGENTS: COMMIT MESSAGES AND PR TITLES

**ALL commits and PR titles MUST follow conventional commits format. This is enforced in CI.**

### Format (REQUIRED)
```
[TASK-ID] <type>(<scope>): <subject>
```

**OR (without task ID):**
```
<type>(<scope>): <subject>
```

### Valid Types (ONLY these are allowed)
- `feat` - New feature
- `fix` - Bug fix  
- `docs` - Documentation
- `style` - Code style/formatting
- `refactor` - Code refactoring
- `test` - Tests
- `chore` - Maintenance
- `perf` - Performance

### Examples (CORRECT ✅)
- `[CF-001] feat(cloudflare): add Turnstile challenge variation`
- `fix(encoding): correct URL encoding for special characters`
- `docs(readme): update installation instructions`
- `test(builder): add TransformBuilder tests`

### Examples (INCORRECT ❌ - DO NOT USE)
- ❌ `Update code`
- ❌ `Fix bug`
- ❌ `Add feature`
- ❌ `Changes`
- ❌ `WIP`
- ❌ `Update README`

### Enforcement
- **CI will FAIL** if commits or PR titles don't follow this format
- **See "Commit Messages" section below for full details**

## Project Overview
redstr is a Rust library for string obfuscation and transformation designed for security testing (red team, blue team, purple team activities). The library provides 30+ transformation functions for WAF bypass, XSS evasion, SQL injection testing, phishing detection, and bot detection evasion.

## Core Principles

### 1. Zero Dependencies
- **CRITICAL**: The core library MUST use only Rust's standard library (`std`)
- Never add external dependencies to core functionality
- Optional features (like `serde`) should be behind feature flags
- When suggesting dependencies, always question if `std` can handle it
- Prefer implementing algorithms manually over adding crates

### 2. Security-Focused Design
- All functions should be designed with security testing use cases in mind
- Consider red team (offensive), blue team (defensive), and purple team (collaborative) perspectives
- Functions should help with:
  - WAF bypass techniques
  - XSS/SQL injection evasion
  - Phishing domain generation
  - Bot detection evasion
  - Filter and detection validation
- Document security use cases in function doc comments

### 3. Performance Optimization
- Use efficient string operations (prefer `String::with_capacity` when size is known)
- Avoid unnecessary allocations
- Use iterators and functional patterns where appropriate
- Consider UTF-8 encoding implications for all string operations
- Profile performance-critical paths

### 4. Code Quality Standards

#### Rust Best Practices
- Use `edition = "2021"` Rust features
- Follow Rust naming conventions:
  - Functions: `snake_case`
  - Types: `PascalCase`
  - Constants: `SCREAMING_SNAKE_CASE`
- Use `&str` for input parameters (borrowing)
- Return `String` for transformed output
- Prefer `&str` over `String` in function signatures when possible
- Use `Result` types for operations that can fail (though most transformations should not fail)
- Handle Unicode properly - use `char` iteration, not byte iteration for text transformations

#### Documentation
- Every public function MUST have:
  - A doc comment with `///` describing what it does
  - `# Examples` section with at least one usage example
  - Security use case notes when relevant
- Include real-world examples in doc comments
- Document any non-obvious behavior or edge cases
- Reference related functions in doc comments

#### Testing
- Write unit tests for all public functions
- Test edge cases: empty strings, Unicode characters, special characters
- Test deterministic functions for exact output
- Test non-deterministic functions for expected properties (length, character preservation, etc.)
- Use `#[cfg(test)]` for test modules
- **MANDATORY**: Run `cargo test` before committing changes
- All tests must pass before committing

### 5. API Design

#### Function Signatures
- All transformation functions should follow: `fn function_name(input: &str) -> String`
- Functions should be pure (no side effects, deterministic when possible)
- For non-deterministic functions (random transformations), use internal RNG seeded from system time
- Keep functions focused on single responsibilities

#### Builder Pattern
- Use `TransformBuilder` for chaining multiple transformations
- Builder methods should consume `self` and return `Self` (owned)
- Builder should have a `.build()` method that returns the final `String`
- Add new builder methods when new transformations are added

#### Error Handling
- Most transformations should not fail (they operate on strings)
- If a transformation can fail, use `Result<String, Error>`
- Prefer panicking over silent failures for programming errors (e.g., invalid indices)

### 6. Project Structure
- Library code: `src/lib.rs`
- CLI binary: `src/main.rs` (only built with `cli` feature)
- Examples: `examples/` directory
- Tests: In `#[cfg(test)]` modules within source files
- Documentation: Comprehensive README.md with use cases

### 7. Feature Flags
- `default`: Core library only (no dependencies)
- `cli`: Enable CLI binary (`src/main.rs`)
- `serde`: Optional serde integration for serialization
- Always check feature flags when adding optional functionality

### 8. Publishing and Versioning
- Follow semantic versioning
- Update version in `Cargo.toml` before releases
- Publishing is automated via GitHub Actions on version tags (`v*`)
- Ensure all features work correctly before tagging releases

### 9. Code Style Guidelines

#### Formatting
- **MANDATORY**: Run `cargo fmt` before every commit
- Formatting is automatically checked in CI and will fail if not formatted
- Use 4 spaces for indentation
- Keep line length reasonable (aim for < 100 characters)
- Run `cargo fmt --check` to verify formatting without modifying files

#### Clippy
- **MANDATORY**: Run `cargo clippy -- -D warnings` before every commit
- All clippy warnings must be fixed or explicitly allowed with justification
- Prefer clippy suggestions for idiomatic Rust
- Suppress clippy warnings only when necessary with justification
- CI runs `cargo clippy -- -D warnings` and will fail on warnings

#### Commit Messages
- **MANDATORY**: All commits MUST follow conventional commits format
- **CRITICAL FOR AI AGENTS**: When making commits, ALWAYS use conventional commits format
- Format: `[TASK-ID] <type>(<scope>): <subject>`
- Types: `feat`, `fix`, `docs`, `style`, `refactor`, `test`, `chore`, `perf`
- Task ID is optional but recommended (e.g., `[CF-001]`)
- Examples:
  - `[CF-001] feat(cloudflare): add Turnstile challenge variation`
  - `fix(encoding): correct URL encoding for special characters`
  - `docs(readme): update installation instructions`
- Commit messages are automatically validated using `cc-check` in CI
- **AI AGENTS MUST**: Before committing, verify the commit message follows the format above
- **AI AGENTS MUST**: Use the exact format - no variations, no exceptions
- See `CONTRIBUTING.md` for detailed commit message guidelines

#### Pull Request Titles (AI Agents)
- **MANDATORY**: PR titles MUST also follow conventional commits format
- Format: `[TASK-ID] <type>(<scope>): <subject>`
- PR titles are validated in CI and will fail if not in conventional commits format
- Examples:
  - `[CF-001] feat(cloudflare): add Turnstile challenge variation`
  - `fix(encoding): correct URL encoding for special characters`
  - `docs(readme): update installation instructions`
- **AI AGENTS MUST**: When creating PRs, use conventional commits format for the title

#### Imports
- Group imports: std, external crates, local modules
- Use `use redstr::*;` in examples for simplicity
- Use explicit imports in library code for clarity

### 10. Security Considerations
- This library is for authorized security testing only
- Always include responsible use warnings in documentation
- Functions should not execute actual attacks, only generate test payloads
- Be mindful of homoglyph and typosquatting functions - document ethical use

### 11. When Adding New Functions
1. Check if it fits the security testing use case
2. Implement using only `std` library
3. Add comprehensive documentation with examples
4. Write unit tests covering edge cases
5. Add to `TransformBuilder` if it makes sense to chain
6. Update README.md with the new function
7. Add CLI support if applicable (in `src/main.rs`)
8. Consider adding to examples directory

### 12. Common Patterns

#### Random Number Generation
- Use internal `SimpleRng` struct for deterministic randomness
- Seed from system time: `SystemTime::now().duration_since(UNIX_EPOCH)`
- Use LCG (Linear Congruential Generator) for simple randomness needs

#### String Transformation Pattern
```rust
pub fn transformation(input: &str) -> String {
    input
        .chars()
        .map(|c| {
            // transformation logic
            transformed_char
        })
        .collect()
}
```

#### Builder Pattern Pattern
```rust
pub fn transformation(mut self) -> Self {
    self.text = transformation_function(&self.text);
    self
}
```

## Examples of Good Code

### Good Function Design
```rust
/// Applies ROT13 cipher to the input.
///
/// ROT13 is a simple letter substitution cipher that replaces each letter
/// with the letter 13 positions after it in the alphabet.
///
/// # Examples
///
/// ```
/// use redstr::rot13;
/// assert_eq!(rot13("Hello"), "Uryyb");
/// assert_eq!(rot13("Uryyb"), "Hello"); // ROT13 is reversible
/// ```
pub fn rot13(input: &str) -> String {
    input
        .chars()
        .map(|c| {
            match c {
                'a'..='z' => {
                    let offset = ((c as u8 - b'a' + 13) % 26) + b'a';
                    offset as char
                }
                'A'..='Z' => {
                    let offset = ((c as u8 - b'A' + 13) % 26) + b'A';
                    offset as char
                }
                _ => c,
            }
        })
        .collect()
}
```

## What NOT to Do

1. ❌ Don't add external dependencies to core library
2. ❌ Don't use `unsafe` code unless absolutely necessary
3. ❌ Don't skip documentation for public functions
4. ❌ Don't write functions that mutate input (always return new String)
5. ❌ Don't ignore Unicode - always use `char` iteration, not byte iteration
6. ❌ Don't add features that don't relate to security testing
7. ❌ Don't commit code that doesn't pass `cargo test` and `cargo clippy -- -D warnings`
8. ❌ Don't break the zero-dependency principle
9. ❌ Don't commit without following conventional commits format - commits are validated in CI and will FAIL
10. ❌ Don't create PRs without conventional commits format in title - PR titles are validated in CI and will FAIL
11. ❌ Don't commit without running `cargo fmt` - formatting is enforced in CI
12. ❌ Don't commit without running `cargo check` - code must compile
13. ❌ **AI AGENTS: NEVER use generic commit messages like "Update code" or "Fix bug" - ALWAYS use conventional commits format**

## Workflow

1. Make changes to code
2. **ALWAYS run `cargo fmt` before committing** - Formatting is enforced in CI
3. **ALWAYS run `cargo check` before committing** - Ensures code compiles
4. Run `cargo clippy -- -D warnings` to check for issues
5. Run `cargo test` to ensure all tests pass
6. Update documentation if needed
7. Check that examples still work: `cargo run --example basic_usage`
8. Verify no new dependencies were added (check `Cargo.toml`)
9. **Write commit message following conventional commits format** (see Commit Messages section above)
10. **AI AGENTS: Before committing, double-check the commit message matches: `[TASK-ID] <type>(<scope>): <subject>`**
11. Commit messages are validated in CI - ensure format is correct before pushing
12. **AI AGENTS: When creating PRs, use conventional commits format for PR title as well**

**Pre-commit Checklist:**
- ✅ `cargo fmt` - Code is formatted (automatically checked by pre-commit hook)
- ✅ `cargo check` - Code compiles (automatically checked by pre-commit hook)
- ✅ `cargo clippy -- -D warnings` - No clippy warnings (automatically checked by pre-commit hook)
- ✅ `cargo test` - All tests pass (automatically checked by pre-commit hook)
- ✅ Commit message follows conventional commits format (validated in CI)

**Note:** A pre-commit hook automatically runs all the above checks (except commit message format) before each commit. All checks must pass before committing. Use `git commit --no-verify` only for WIP commits, never for final commits.

## Integration Examples
When suggesting code for integration with tools like Caido, Burp Suite, or EvilJinx, focus on:
- Simple, clean API usage
- Performance considerations for high-throughput scenarios
- Real-world security testing patterns
- Chain transformations using `TransformBuilder` for complex payloads

## Working with Multiple Projects

This workspace may contain multiple related projects (e.g., `redstr`, `redstr-server`, `redstr-burp`, `redstr-caido`, `redstr-eviljinx`, `redstr-owasp-zap`). When working with multiple projects:

### Discovering Projects

**Always check for existing projects before making assumptions:**
```bash
# Find all Cargo.toml files (Rust projects)
find /workspace -name "Cargo.toml" -type f

# Find all directories that might be projects
ls -d /workspace/*/

# Check for git repositories
find /workspace -name ".git" -type d
```

### Navigating Between Projects

**CRITICAL: Always verify your current directory before making changes:**
- Use `cd /workspace/project-name` to navigate
- Always use `pwd` to verify location
- Use absolute paths (`/workspace/project-name/file.rs`) when switching between projects
- Use relative paths only when working within a single project

**Before making any changes:**
1. Navigate to the project directory: `cd /workspace/redstr-server`
2. Verify location: `pwd && ls -la`
3. Check project structure: `read_file("Cargo.toml")` or `cat Cargo.toml`
4. Understand the project's dependencies and structure

### Git Operations for Multiple Projects

**Each project may have its own git repository:**
- Check if project has its own `.git`: `cd /workspace/redstr-server && [ -d ".git" ] && git status`
- Always create branches from the correct project directory
- Always commit from the project's root directory
- Use project-specific branch names: `feat/server-api-endpoints` or `redstr-server/feat/api-endpoints`

**Commits for multiple projects:**
- Use conventional commits format with project-specific scope:
  - `feat(server): add POST /transform endpoint` - for redstr-server
  - `fix(burp): correct extension initialization` - for redstr-burp
  - `docs(caido): update plugin documentation` - for redstr-caido
- **CRITICAL**: Always commit from the project root where you made changes
- Verify which repo you're in: `git remote -v` and `git status`

### Building and Testing Multiple Projects

**For each project independently:**
```bash
# Navigate to project
cd /workspace/redstr-server

# Build
cargo build

# Test
cargo test

# Format
cargo fmt

# Clippy
cargo clippy -- -D warnings
```

**When working with dependencies:**
- If `redstr-server` depends on `redstr`, ensure `redstr` is published or use path dependency
- Check `Cargo.toml` for dependency configuration
- Build parent projects before dependent projects if using path dependencies

### Creating Pull Requests for Multiple Projects

**For each project:**
1. Navigate to project root: `cd /workspace/redstr-server`
2. Create feature branch: `git checkout -b feat/server-new-endpoint`
3. Make changes and commit (following conventional commits format)
4. Push branch: `git push origin feat/server-new-endpoint`
5. PR title must follow conventional commits: `feat(server): add new endpoint`

**PR Title Format (per project):**
- `feat(server): add POST /transform endpoint` - for redstr-server
- `fix(burp): correct extension initialization` - for redstr-burp
- `docs(caido): update plugin documentation` - for redstr-caido

### Project-Specific Rules

**Each project may have:**
- Different `Cargo.toml` configurations
- Different dependency requirements
- Different CI/CD workflows (check `.github/workflows/`)
- Project-specific `.cursorrules` (check project directory)
- Project-specific `CONTRIBUTING.md`

**Always check project-specific files before making changes:**
- `.cursorrules` in project directory (if exists)
- `CONTRIBUTING.md` in project directory
- `.github/workflows/` for CI requirements
- Project-specific README.md

### Best Practices for Multi-Project Work

1. **Always verify location**: Use `pwd` before making changes
2. **Use absolute paths**: When switching between projects, use `/workspace/project-name/`
3. **Project-specific commits**: Include project context in commit scope (e.g., `feat(server): ...`)
4. **Test each project**: Run tests in the project you're modifying
5. **Check dependencies**: Ensure dependent projects still work after changes
6. **Document changes**: Update relevant README files for each project
7. **Follow project conventions**: Each project may have specific rules

### Commit Message Scopes by Project

- **redstr**: `encoding`, `cloudflare`, `builder`, `transformations`, `obfuscation`, `injection`, `phishing`, `bot_detection`, `unicode`, `web_security`, `shell`, `case`
- **redstr-server**: `server`, `api`, `endpoint`, `handler`, `middleware`, `route`
- **redstr-burp**: `burp`, `extension`, `tab`, `intruder`, `scanner`
- **redstr-caido**: `caido`, `plugin`, `workflow`, `integration`
- **redstr-eviljinx**: `eviljinx`, `script`, `integration`
- **redstr-owasp-zap**: `zap`, `addon`, `scanner`, `active-scan`

### Troubleshooting Multi-Project Issues

**Problem: Can't find project**
```bash
find /workspace -name "Cargo.toml" -type f
find /workspace -type d -name "*server*"
```

**Problem: Wrong project directory**
```bash
pwd
ls -la
cat Cargo.toml  # Verify project name
```

**Problem: Git operations in wrong repo**
```bash
git remote -v
git status
```

**Problem: Dependencies not found**
```bash
# Check if parent project needs to be built first
cd /workspace
cargo build --release

# Or check if path dependency is needed
cd /workspace/redstr-server
cat Cargo.toml  # Check dependency configuration
```

### Quick Reference Commands

```bash
# Find all projects
find /workspace -name "Cargo.toml" -type f

# Navigate to project
cd /workspace/redstr-server

# Verify location
pwd && cat Cargo.toml | grep "^name"

# Check git status
git status

# Build and test
cargo build && cargo test && cargo clippy -- -D warnings

# Format code
cargo fmt

# Commit (from project root)
git commit -m "feat(scope): description"

# Push branch
git push origin branch-name
```

**CRITICAL REMINDERS:**
- Always use conventional commits format for ALL projects
- Each project should be tested independently
- Always verify your current directory with `pwd` before making changes
- Use project-specific scopes in commit messages
- PR titles must follow conventional commits format for each project
