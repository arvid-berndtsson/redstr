# Language Bindings Implementation Guide

## Overview

This document provides a concrete implementation plan for creating native language bindings for redstr. Based on industry best practices from projects like tree-sitter, swc, Polars, and libsodium, **native bindings are the recommended approach** for library adoption.

## Why Native Bindings Over API Server

| Factor | API Server | Native Bindings |
|--------|------------|-----------------|
| **Latency** | 5-10ms per call | <0.01ms per call |
| **DX (Developer Experience)** | HTTP client code | Native imports, autocomplete |
| **Offline support** | ❌ Requires server | ✅ Works offline |
| **Type safety** | Manual types | Auto-generated types |
| **Distribution** | Deploy server + client | Single package install |
| **Adoption barrier** | Higher (infra needed) | Lower (just `npm install`) |

**Verdict**: For library adoption, native bindings are essential. The API server is good for quick prototyping or microservices architecture, but bindings drive adoption.

---

## Implementation Options

### Option 1: UniFFI (Recommended for Multiple Languages)

Mozilla's UniFFI generates bindings for Kotlin, Swift, Python, and Ruby from a single interface definition.

**Pros:**
- Single definition, multiple languages
- Battle-tested by Firefox
- Automatic type conversion

**Cons:**
- Doesn't support JavaScript/TypeScript directly
- Requires separate napi-rs for Node.js

**Best for:** Python, Swift, Kotlin bindings

### Option 2: Language-Specific Frameworks (Recommended)

Use the best tool for each language:

| Language | Framework | Maturity | Notes |
|----------|-----------|----------|-------|
| **Node.js/TypeScript** | napi-rs | ⭐⭐⭐⭐⭐ | Used by swc, Prisma, Parcel |
| **Python** | PyO3 + maturin | ⭐⭐⭐⭐⭐ | Used by Polars, Ruff, cryptography |
| **Browser (WASM)** | wasm-bindgen | ⭐⭐⭐⭐⭐ | Standard for Rust→WASM |
| **C#/.NET** | C FFI + csbindgen | ⭐⭐⭐⭐ | Used by Unity, game engines |
| **Go** | CGO + C FFI | ⭐⭐⭐⭐ | Standard approach |
| **Ruby** | magnus | ⭐⭐⭐ | Growing ecosystem |

### Option 3: C FFI Core (Maximum Compatibility)

Create a C-compatible FFI layer that any language can consume.

**Pros:**
- Works with virtually any language
- Single binding layer to maintain
- Used by libsodium, SQLite

**Cons:**
- Manual memory management in bindings
- More boilerplate in wrapper code

---

## Recommended Implementation Plan

### Phase 1: C FFI Foundation

Add a C FFI layer to the core redstr library. This enables all other bindings.

#### Step 1.1: Add C FFI Feature Flag

```toml
# Cargo.toml
[features]
default = []
cli = []
ffi = []  # C FFI exports

[lib]
crate-type = ["rlib", "cdylib", "staticlib"]
```

#### Step 1.2: Create FFI Module

```rust
// src/ffi.rs
#![cfg(feature = "ffi")]

use std::ffi::{CStr, CString};
use std::os::raw::c_char;

/// Free a string allocated by redstr
/// 
/// # Safety
/// The pointer must have been returned by a redstr function
#[no_mangle]
pub unsafe extern "C" fn redstr_free_string(s: *mut c_char) {
    if !s.is_null() {
        drop(CString::from_raw(s));
    }
}

/// Apply leetspeak transformation
/// 
/// # Safety
/// Input must be a valid null-terminated UTF-8 string
#[no_mangle]
pub unsafe extern "C" fn redstr_leetspeak(input: *const c_char) -> *mut c_char {
    let c_str = CStr::from_ptr(input);
    let input_str = match c_str.to_str() {
        Ok(s) => s,
        Err(_) => return std::ptr::null_mut(),
    };
    
    let result = crate::leetspeak(input_str);
    
    match CString::new(result) {
        Ok(s) => s.into_raw(),
        Err(_) => std::ptr::null_mut(),
    }
}

/// Apply base64 encoding
#[no_mangle]
pub unsafe extern "C" fn redstr_base64_encode(input: *const c_char) -> *mut c_char {
    let c_str = CStr::from_ptr(input);
    let input_str = match c_str.to_str() {
        Ok(s) => s,
        Err(_) => return std::ptr::null_mut(),
    };
    
    let result = crate::base64_encode(input_str);
    
    match CString::new(result) {
        Ok(s) => s.into_raw(),
        Err(_) => std::ptr::null_mut(),
    }
}

// ... repeat for all public functions
```

#### Step 1.3: Generate C Header

Use `cbindgen` to automatically generate the C header:

```toml
# cbindgen.toml
language = "C"
header = "/* redstr C bindings - auto-generated */"
include_guard = "REDSTR_H"
autogen_warning = "/* DO NOT MODIFY - Generated by cbindgen */"

[export]
prefix = "redstr_"
```

```bash
# Generate header
cbindgen --config cbindgen.toml --crate redstr --output include/redstr.h
```

Generated header:
```c
// include/redstr.h
#ifndef REDSTR_H
#define REDSTR_H

#include <stdint.h>

#ifdef __cplusplus
extern "C" {
#endif

// Free a string allocated by redstr
void redstr_free_string(char *s);

// Transformations
char *redstr_leetspeak(const char *input);
char *redstr_base64_encode(const char *input);
char *redstr_base64_decode(const char *input);
char *redstr_url_encode(const char *input);
char *redstr_rot13(const char *input);
// ... all other functions

#ifdef __cplusplus
}
#endif

#endif // REDSTR_H
```

---

### Phase 2: Node.js / TypeScript Bindings (Highest Priority)

React apps and Node.js backends are the primary target.

#### Repository: `redstr-npm`

```
redstr-npm/
├── Cargo.toml
├── package.json
├── src/
│   └── lib.rs              # napi-rs bindings
├── index.js                # Platform loader
├── index.d.ts              # TypeScript definitions
├── npm/                    # Platform-specific packages
│   ├── darwin-arm64/
│   ├── darwin-x64/
│   ├── linux-arm64-gnu/
│   ├── linux-x64-gnu/
│   ├── linux-x64-musl/
│   └── win32-x64-msvc/
├── __test__/
│   └── index.spec.ts
└── README.md
```

#### Cargo.toml

```toml
[package]
name = "redstr-npm"
version = "0.1.0"
edition = "2021"

[lib]
crate-type = ["cdylib"]

[dependencies]
napi = { version = "2", features = ["napi4"] }
napi-derive = "2"
redstr = "0.2"

[build-dependencies]
napi-build = "2"

[profile.release]
lto = true
strip = true
```

#### src/lib.rs

```rust
use napi::bindgen_prelude::*;
use napi_derive::napi;

// Re-export all redstr functions with #[napi] attribute

#[napi]
pub fn leetspeak(input: String) -> String {
    redstr::leetspeak(&input)
}

#[napi]
pub fn base64_encode(input: String) -> String {
    redstr::base64_encode(&input)
}

#[napi]
pub fn base64_decode(input: String) -> String {
    redstr::base64_decode(&input)
}

#[napi]
pub fn url_encode(input: String) -> String {
    redstr::url_encode(&input)
}

#[napi]
pub fn rot13(input: String) -> String {
    redstr::rot13(&input)
}

#[napi]
pub fn case_swap(input: String) -> String {
    redstr::case_swap(&input)
}

#[napi]
pub fn homoglyph_substitution(input: String) -> String {
    redstr::homoglyph_substitution(&input)
}

#[napi]
pub fn domain_typosquat(input: String) -> String {
    redstr::domain_typosquat(&input)
}

#[napi]
pub fn random_user_agent() -> String {
    redstr::random_user_agent()
}

#[napi]
pub fn xss_tag_variations(input: String) -> String {
    redstr::xss_tag_variations(&input)
}

#[napi]
pub fn sql_comment_injection(input: String) -> String {
    redstr::sql_comment_injection(&input)
}

// Builder pattern
#[napi]
pub struct TransformBuilder {
    inner: redstr::TransformBuilder,
}

#[napi]
impl TransformBuilder {
    #[napi(constructor)]
    pub fn new(input: String) -> Self {
        Self {
            inner: redstr::TransformBuilder::new(&input),
        }
    }

    #[napi]
    pub fn leetspeak(&mut self) -> &Self {
        self.inner = std::mem::take(&mut self.inner).leetspeak();
        self
    }

    #[napi]
    pub fn base64(&mut self) -> &Self {
        self.inner = std::mem::take(&mut self.inner).base64();
        self
    }

    #[napi]
    pub fn url_encode(&mut self) -> &Self {
        self.inner = std::mem::take(&mut self.inner).url_encode();
        self
    }

    #[napi]
    pub fn case_swap(&mut self) -> &Self {
        self.inner = std::mem::take(&mut self.inner).case_swap();
        self
    }

    #[napi]
    pub fn build(&self) -> String {
        self.inner.clone().build()
    }
}
```

#### index.d.ts (Auto-generated, but shown for reference)

```typescript
// TypeScript definitions
export function leetspeak(input: string): string;
export function base64Encode(input: string): string;
export function base64Decode(input: string): string;
export function urlEncode(input: string): string;
export function rot13(input: string): string;
export function caseSwap(input: string): string;
export function homoglyphSubstitution(input: string): string;
export function domainTyposquat(input: string): string;
export function randomUserAgent(): string;
export function xssTagVariations(input: string): string;
export function sqlCommentInjection(input: string): string;

export class TransformBuilder {
    constructor(input: string);
    leetspeak(): this;
    base64(): this;
    urlEncode(): this;
    caseSwap(): this;
    build(): string;
}
```

#### Usage in React/Node.js

```typescript
// Native import - no HTTP calls!
import { leetspeak, TransformBuilder, randomUserAgent } from 'redstr';

// Direct function calls - ~0.01ms
const encoded = leetspeak('password');  // 'p@55w0rd'

// Builder pattern
const payload = new TransformBuilder('<script>alert(1)</script>')
    .caseSwap()
    .urlEncode()
    .build();

// Generate random user agent
const ua = randomUserAgent();
```

---

### Phase 3: Python Bindings

#### Repository: `redstr-python`

```
redstr-python/
├── Cargo.toml
├── pyproject.toml
├── src/
│   └── lib.rs              # PyO3 bindings
├── python/
│   └── redstr/
│       ├── __init__.py
│       └── py.typed        # PEP 561 marker
├── tests/
│   └── test_redstr.py
└── README.md
```

#### Cargo.toml

```toml
[package]
name = "redstr-python"
version = "0.1.0"
edition = "2021"

[lib]
name = "redstr"
crate-type = ["cdylib"]

[dependencies]
pyo3 = { version = "0.20", features = ["extension-module"] }
redstr = "0.2"
```

#### src/lib.rs

```rust
use pyo3::prelude::*;

#[pyfunction]
fn leetspeak(input: &str) -> String {
    redstr::leetspeak(input)
}

#[pyfunction]
fn base64_encode(input: &str) -> String {
    redstr::base64_encode(input)
}

#[pyfunction]
fn url_encode(input: &str) -> String {
    redstr::url_encode(input)
}

#[pyfunction]
fn rot13(input: &str) -> String {
    redstr::rot13(input)
}

#[pyfunction]
fn random_user_agent() -> String {
    redstr::random_user_agent()
}

#[pyfunction]
fn homoglyph_substitution(input: &str) -> String {
    redstr::homoglyph_substitution(input)
}

#[pyfunction]
fn domain_typosquat(input: &str) -> String {
    redstr::domain_typosquat(input)
}

#[pyclass]
struct TransformBuilder {
    text: String,
}

#[pymethods]
impl TransformBuilder {
    #[new]
    fn new(input: &str) -> Self {
        Self { text: input.to_string() }
    }

    fn leetspeak(&mut self) -> PyResult<()> {
        self.text = redstr::leetspeak(&self.text);
        Ok(())
    }

    fn base64(&mut self) -> PyResult<()> {
        self.text = redstr::base64_encode(&self.text);
        Ok(())
    }

    fn url_encode(&mut self) -> PyResult<()> {
        self.text = redstr::url_encode(&self.text);
        Ok(())
    }

    fn build(&self) -> String {
        self.text.clone()
    }
}

#[pymodule]
fn redstr(_py: Python, m: &PyModule) -> PyResult<()> {
    m.add_function(wrap_pyfunction!(leetspeak, m)?)?;
    m.add_function(wrap_pyfunction!(base64_encode, m)?)?;
    m.add_function(wrap_pyfunction!(url_encode, m)?)?;
    m.add_function(wrap_pyfunction!(rot13, m)?)?;
    m.add_function(wrap_pyfunction!(random_user_agent, m)?)?;
    m.add_function(wrap_pyfunction!(homoglyph_substitution, m)?)?;
    m.add_function(wrap_pyfunction!(domain_typosquat, m)?)?;
    m.add_class::<TransformBuilder>()?;
    Ok(())
}
```

#### Usage in Python

```python
# Native import - no HTTP calls!
from redstr import leetspeak, TransformBuilder, random_user_agent

# Direct function calls
encoded = leetspeak('password')  # 'p@55w0rd'

# Builder pattern
builder = TransformBuilder('<script>alert(1)</script>')
builder.case_swap()
builder.url_encode()
payload = builder.build()

# Random user agent
ua = random_user_agent()
```

---

### Phase 4: .NET/C# Bindings

#### Repository: `redstr-csharp`

Uses C FFI with P/Invoke.

```
redstr-csharp/
├── src/
│   └── Redstr/
│       ├── Redstr.csproj
│       ├── Native.cs           # P/Invoke declarations
│       ├── Redstr.cs           # High-level API
│       └── TransformBuilder.cs
├── native/
│   ├── build.sh               # Build native libraries
│   └── redstr-ffi/            # Rust FFI crate
├── tests/
│   └── Redstr.Tests/
├── Redstr.sln
└── README.md
```

#### Native.cs

```csharp
using System;
using System.Runtime.InteropServices;

namespace Redstr
{
    internal static class Native
    {
        private const string LibName = "redstr";

        [DllImport(LibName, CallingConvention = CallingConvention.Cdecl)]
        public static extern IntPtr redstr_leetspeak(
            [MarshalAs(UnmanagedType.LPUTF8Str)] string input);

        [DllImport(LibName, CallingConvention = CallingConvention.Cdecl)]
        public static extern IntPtr redstr_base64_encode(
            [MarshalAs(UnmanagedType.LPUTF8Str)] string input);

        [DllImport(LibName, CallingConvention = CallingConvention.Cdecl)]
        public static extern IntPtr redstr_url_encode(
            [MarshalAs(UnmanagedType.LPUTF8Str)] string input);

        [DllImport(LibName, CallingConvention = CallingConvention.Cdecl)]
        public static extern void redstr_free_string(IntPtr s);

        // Helper to convert native string to managed string
        public static string PtrToStringAndFree(IntPtr ptr)
        {
            if (ptr == IntPtr.Zero) return string.Empty;
            
            var result = Marshal.PtrToStringUTF8(ptr);
            redstr_free_string(ptr);
            return result ?? string.Empty;
        }
    }
}
```

#### Redstr.cs

```csharp
namespace Redstr
{
    public static class Transforms
    {
        public static string Leetspeak(string input)
            => Native.PtrToStringAndFree(Native.redstr_leetspeak(input));

        public static string Base64Encode(string input)
            => Native.PtrToStringAndFree(Native.redstr_base64_encode(input));

        public static string UrlEncode(string input)
            => Native.PtrToStringAndFree(Native.redstr_url_encode(input));

        // ... all other functions
    }

    public class TransformBuilder
    {
        private string _text;

        public TransformBuilder(string input) => _text = input;

        public TransformBuilder Leetspeak()
        {
            _text = Transforms.Leetspeak(_text);
            return this;
        }

        public TransformBuilder Base64()
        {
            _text = Transforms.Base64Encode(_text);
            return this;
        }

        public TransformBuilder UrlEncode()
        {
            _text = Transforms.UrlEncode(_text);
            return this;
        }

        public string Build() => _text;
    }
}
```

#### Usage in .NET

```csharp
using Redstr;

// Direct function calls
var encoded = Transforms.Leetspeak("password");  // "p@55w0rd"

// Builder pattern
var payload = new TransformBuilder("<script>alert(1)</script>")
    .CaseSwap()
    .UrlEncode()
    .Build();
```

---

### Phase 5: WebAssembly (Browser)

For client-side React apps running in browsers.

#### Repository: `redstr-wasm`

```
redstr-wasm/
├── Cargo.toml
├── src/
│   └── lib.rs
├── pkg/                    # Generated by wasm-pack
│   ├── redstr_wasm.js
│   ├── redstr_wasm.d.ts
│   ├── redstr_wasm_bg.wasm
│   └── package.json
├── examples/
│   └── react-app/
└── README.md
```

#### Cargo.toml

```toml
[package]
name = "redstr-wasm"
version = "0.1.0"
edition = "2021"

[lib]
crate-type = ["cdylib"]

[dependencies]
wasm-bindgen = "0.2"
redstr = "0.2"

[profile.release]
opt-level = "s"
lto = true
```

#### src/lib.rs

```rust
use wasm_bindgen::prelude::*;

#[wasm_bindgen]
pub fn leetspeak(input: &str) -> String {
    redstr::leetspeak(input)
}

#[wasm_bindgen]
pub fn base64_encode(input: &str) -> String {
    redstr::base64_encode(input)
}

#[wasm_bindgen]
pub fn url_encode(input: &str) -> String {
    redstr::url_encode(input)
}

#[wasm_bindgen]
pub fn rot13(input: &str) -> String {
    redstr::rot13(input)
}

// ... all other functions
```

#### Usage in React (Browser)

```typescript
import init, { leetspeak, base64_encode } from 'redstr-wasm';

// Initialize WASM module (once on app load)
await init();

// Then use synchronously - runs in browser, no server needed!
const encoded = leetspeak('password');
```

---

## Implementation Timeline

| Phase | Target | Timeline | Effort |
|-------|--------|----------|--------|
| **Phase 1** | C FFI Foundation | 1 week | Add to core repo |
| **Phase 2** | npm Package (napi-rs) | 2 weeks | Separate repo |
| **Phase 3** | Python Package (PyO3) | 2 weeks | Separate repo |
| **Phase 4** | .NET Package (P/Invoke) | 2 weeks | Separate repo |
| **Phase 5** | WASM Package | 1 week | Separate repo |

## Tooling Recommendations

### For Code Generation

As the library grows (500+ functions), use automated binding generation:

1. **cbindgen** - Generate C headers from Rust
2. **napi-rs** - Auto-generates TypeScript definitions
3. **PyO3** - Generates Python type stubs
4. **csbindgen** - Generate C# bindings from Rust

### CI/CD

Each binding repository needs:
- Cross-platform builds (Linux, macOS, Windows)
- ARM64 + x64 support
- Automated publishing to package managers
- Version sync with core library

---

## Summary

**Native bindings are the right choice** for library adoption. The implementation order should be:

1. **C FFI layer** in core (enables all bindings)
2. **npm package** (highest demand: React, Node.js)
3. **Python package** (security community uses Python heavily)
4. **WASM package** (browser-based React apps)
5. **.NET package** (enterprise backends)

The API server remains valuable for:
- Quick prototyping
- Microservices architecture
- Languages without bindings yet
- Centralized deployment scenarios
