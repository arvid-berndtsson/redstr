# Language Bindings for redstr

This document explains how redstr provides support for multiple programming languages through language-specific bindings maintained in separate repositories.

## Overview

The `redstr` core repository contains only the Rust library implementation. Support for other programming languages is provided through language-specific binding repositories that depend on the core library. This architecture provides clean separation of concerns and independent versioning for each language.

## Architecture

### Core Repository (`redstr`)

- **Purpose**: Pure Rust library implementation
- **Contains**: Core string transformation functions
- **Dependencies**: Zero external dependencies (Rust standard library only)
- **Exports**: Public Rust API surface
- **Version**: Follows semantic versioning

### Binding Repositories (`redstr-LANGUAGE`)

Each language has its own dedicated repository that:
- Depends on the core `redstr` Rust crate
- Provides language-specific bindings and idiomatic API
- Includes language-specific tests, examples, and documentation
- Has independent versioning and release cycles
- Manages language-specific CI/CD pipelines

## Supported Languages

### Officially Maintained Bindings

| Language | Repository | Package Manager | Status |
|----------|------------|-----------------|--------|
| Go | `redstr-go` | Go modules | Planned |
| JavaScript/TypeScript | `redstr-npm` | npm | Planned |
| Python | `redstr-python` | PyPI | Future |
| Java | `redstr-java` | Maven Central | Future |
| C#/.NET | `redstr-csharp` | NuGet | Future |

## Repository Structure

### Binding Repository Layout

Each language binding repository follows this general structure:

```
redstr-LANGUAGE/
├── README.md              # Language-specific documentation
├── CHANGELOG.md           # Version history
├── LICENSE               # License file (same as core)
├── examples/             # Usage examples
├── tests/                # Language-specific tests
├── src/                  # Binding implementation
├── .github/workflows/    # CI/CD for building and testing
└── [language-specific files]
```

### Example: Go Bindings (`redstr-go`)

```
redstr-go/
├── README.md
├── CHANGELOG.md
├── go.mod
├── go.sum
├── redstr.go            # Go wrapper functions
├── redstr_test.go       # Go tests
├── examples/
│   ├── basic/
│   └── security/
└── .github/workflows/
    └── ci.yml
```

### Example: npm Bindings (`redstr-npm`)

```
redstr-npm/
├── README.md
├── CHANGELOG.md
├── package.json
├── Cargo.toml           # napi-rs bindings crate
├── src/
│   └── lib.rs          # Rust wrapper functions with #[napi]
├── index.js            # Platform detection
├── index.d.ts          # TypeScript definitions
├── examples/
└── __test__/
```

## Binding Implementation Strategies

### Strategy 1: C FFI (Go, Python, etc.)

For languages that can interface with C:

1. **Core exports C FFI**: Core library can optionally provide C-compatible FFI functions
2. **Language wrapper**: Binding repository implements language-specific wrappers
3. **Memory management**: Binding handles string marshaling and memory safety

**Pros**: Wide language compatibility, mature tooling
**Cons**: Requires C FFI layer, manual string marshaling

### Strategy 2: Native Bindings (npm via napi-rs)

For languages with Rust binding frameworks:

1. **Direct Rust bindings**: Use language-specific Rust binding framework
2. **No C layer**: Direct Rust ↔ Language communication
3. **Type safety**: Framework handles type conversion

**Pros**: Better performance, type safety, simpler implementation
**Cons**: Framework-specific, limited to supported languages

### Strategy 3: WASM (Web Browsers)

For web browser targets:

1. **Compile to WebAssembly**: Use `wasm-bindgen` or similar
2. **JavaScript glue code**: Auto-generated by framework
3. **Browser-compatible**: Runs in all modern browsers

**Pros**: Universal browser support, near-native performance
**Cons**: Bundle size considerations, async-only API

## Development Workflow

### Creating a New Language Binding

1. **Create Repository**: Create `redstr-LANGUAGE` repository
2. **Add Core Dependency**: Reference core `redstr` crate
3. **Implement Bindings**: Create language-specific wrappers
4. **Add Tests**: Comprehensive test suite for all functions
5. **Add Examples**: Usage examples and best practices
6. **Configure CI/CD**: Automated building, testing, and publishing
7. **Document**: Language-specific README with installation and usage

### Maintaining Version Compatibility

**Core Library Updates**:
- Core `redstr` follows semantic versioning
- Breaking changes increment major version
- New functions increment minor version
- Bug fixes increment patch version

**Binding Updates**:
- Bindings specify core version compatibility (e.g., `redstr = "0.1"`)
- Bindings can have independent versioning
- Update bindings when core adds new functions
- Test bindings against core updates

### Release Process

**Core Library**:
1. Update version in `Cargo.toml`
2. Update `CHANGELOG.md`
3. Run full test suite
4. Publish to crates.io
5. Create GitHub release tag

**Language Bindings**:
1. Update core dependency version
2. Update wrapper code for new functions
3. Update binding version
4. Update `CHANGELOG.md`
5. Run full test suite
6. Publish to language-specific package manager
7. Create GitHub release tag

## Testing Strategy

### Core Library Testing

- **Unit tests**: Test each transformation function
- **Edge cases**: Empty strings, special characters, Unicode
- **Property tests**: Validate transformation properties
- **Benchmarks**: Performance regression testing

### Binding Testing

Each binding repository should include:

1. **Functionality tests**: Verify all functions work correctly
2. **Interop tests**: Test string marshaling and memory safety
3. **Integration tests**: End-to-end usage scenarios
4. **Platform tests**: Test on target platforms (Linux, macOS, Windows)
5. **Performance tests**: Verify binding overhead is acceptable

## Documentation Requirements

### Core Repository

- **API documentation**: Rust doc comments for all public functions
- **README**: Overview, installation, basic usage
- **Examples**: Common transformation patterns
- **Security**: Responsible use disclaimer

### Binding Repositories

- **Installation**: Language-specific installation instructions
- **API Reference**: All available functions with signatures
- **Examples**: Language-idiomatic usage examples
- **Migration Guide**: For users updating between versions
- **Contributing**: How to contribute to bindings
- **License**: Same as core library

## Security Considerations

### Core Library

- Zero external dependencies
- Standard library only
- Regular security audits
- Prompt CVE response

### Bindings

- Minimal external dependencies
- Secure string marshaling
- Memory safety guarantees
- Regular dependency updates
- Security advisories for binding-specific issues

## Performance Considerations

### Binding Overhead

- **Acceptable overhead**: <10% compared to pure Rust
- **String copying**: Minimize unnecessary allocations
- **Batch operations**: Provide APIs for bulk transformations
- **Lazy evaluation**: Where appropriate for language

### Benchmarking

Each binding should include benchmarks comparing:
- Native language implementations (if available)
- Core Rust performance
- Binding overhead measurement

## Community Contributions

### Contributing New Bindings

To contribute a new language binding:

1. **Propose**: Open issue in core repository
2. **Discuss**: Design and implementation approach
3. **Create Repository**: Following naming convention
4. **Implement**: Complete binding with tests
5. **Document**: Comprehensive documentation
6. **Submit**: Request official status

### Maintenance Model

- **Core Team**: Maintains core library
- **Language Maintainers**: Own specific binding repositories
- **Community**: Contributions via pull requests
- **Governance**: Decision-making in core repository

## Code Generation (Future)

### Automated Binding Generation

As the library scales (500+ functions planned), automated code generation will be introduced:

**Tool**: Standalone binding generator (e.g., `polyglot-bindgen`)

**Capabilities**:
- Parse Rust source function signatures
- Generate FFI wrapper code
- Generate language-specific bindings
- Type mapping for all target languages
- Template-based code generation

**Benefits**:
- Consistency across all bindings
- Reduced maintenance burden
- Faster updates when core changes
- Fewer manual errors

**Implementation Timeline**: To be determined based on function count and maintenance burden

## Migration from Monorepo

Previously, language bindings were maintained in the core repository under `bindings/` directory. This structure was refactored to separate repositories for:

- **Cleaner core**: Focus on Rust implementation
- **Independent versioning**: Each language can evolve separately
- **Better ownership**: Clear maintainer boundaries
- **Simpler CI/CD**: Language-specific workflows
- **Reduced complexity**: Smaller repositories

Existing users should migrate to the new binding repositories when they become available.

## FAQ

### Why separate repositories?

Separate repositories provide:
- Clean separation of concerns
- Independent versioning and releases
- Language-specific CI/CD pipelines
- Clearer ownership and maintenance
- Smaller, focused codebases

### How do I add support for my language?

1. Check if an official binding exists
2. If not, propose a new binding in core repository issues
3. Follow the contribution guidelines above
4. Engage with the community for design feedback

### What if the binding doesn't support all functions?

Bindings should aim for 100% function coverage. If a binding is incomplete:
- Check the binding repository's roadmap
- Open an issue for missing functions
- Consider contributing the implementation

### How are breaking changes handled?

- **Core**: Semantic versioning, breaking changes = major version bump
- **Bindings**: Can introduce language-specific breaking changes independently
- **Communication**: Changelogs and migration guides for all breaking changes

### Can I use multiple language bindings together?

Yes, but ensure they use compatible core library versions. Mixing incompatible versions may cause unexpected behavior.

### What about performance?

- Core library is highly optimized Rust
- Bindings add minimal overhead (<10% typically)
- Native bindings (napi-rs) perform better than FFI
- Each binding includes benchmarks

## Resources

- **Core Repository**: https://github.com/arvid-berndtsson/redstr
- **Core Documentation**: https://docs.rs/redstr
- **Issue Tracker**: https://github.com/arvid-berndtsson/redstr/issues
- **Discussions**: https://github.com/arvid-berndtsson/redstr/discussions

## License

All language bindings must use the same license as the core library to ensure consistency and legal clarity.

---

**Last Updated**: 2025-11-29  
**Version**: 1.0
